## 标识符

1. 标识符由大小写字母、数字和下划线组成，切第一个字符不能是数字。
2. 标识符区分大小写字母，如：“A”和“a”是两个不同的标识符。
3. 关键字不能作为标识符。

## 注释

1. "//"用于单行注释。
2. "/\* \*/"用于多行注释。

## 数据类型

1. 整型  
整型分为短整型，无符号短整型，整型，无符号整型，长整型和无符号长整型。  
**一般常用的为整型**：int
2. 浮点型  
浮点型分为单精度浮点型和双精度浮点型  
单精度浮点型：float  
双精度浮点型：double
3. 字符型  
字符型：char

## 常量

1. 数值型常量  
    1. 整型常量
        * 十进制，由数字 0~9 和正负号组成。
        * 八进制，以数字 0 为前缀，其后由数字 0~7 组成。
        * 十六进制，以 0x 或 0X 为前缀，其后由数字 0~9 和大小写字母（A~F 或 a~f）组成。
    2. 浮点型常量  
        * 小数形式，整数部分或小数部分为0时可以省略不写，默认为 double 型，在常量后加字母 f 或 F 被认为是 float 型。
        * 指数形式，由数字尾数、e 或 E 和指数组成。
2. 字符型常量  
字符常量用单引号括起来，只能包括一个字符，且区分大小写。字符常量为 ASCII 字符集中的任意字符。字符常量可以直接参与运算，使用的是该字符的 ASCII 码值。  
    |转义字符|含义|
    |:---:|:---:|
    \0|空字符
    \a|响铃
    \b|退格
    \t|水平制表符
    \v|竖向跳格
    \n|回车换行
    \r|回车
    \f|换页
    \\'|单引号
    \\"|双引号
    \\\ |反斜杠
1. 符号常量  
用一个标识符表示一个常量,称为符号常量,符号常量使用前必须定义。  
符号常量：\#define 标识符 常量值

## 变量

1. 变量的定义  
变量有变量名和变量值。  
定义变量：类型说明符 变量名表；  
2. 变量的初始化  
在定义变量的同时为其赋初值的过程就叫变量的初始化，也即变量第一次存入数据的过程。  
* 单精度浮点型变量在初始化时，需要在数值后面加 f 或 F 表示该数值为单精度类型，否则被默认为双精度类型。
* 字符型变量在初始化时，其值时用单引号引起来的单个字符。
* 允许字符型数据赋值给整型变量，也允许整型数据赋值给字符变量。  
3. 变量的引用  
变量被定义和初始化后,就可以通过变量名进行引用。

## 算术运算符  

1. 基本运算符
     |运算符|名称|
     |:---:|:---:|
     +|加法运算符
     -|减法运算符
     *|乘法运算符
     /|除法运算符
     %|取余运算符
     1. 运算对象为两个的运算符是双目运算符，运算对象为一个的运算符是单目运算符。
     2. 在除法运算中需注意：
        * 如果 a 和 b 都是整型，则运算结果也是整型。
        * 如果 a 和 b 由一个浮点型，运算时会将 a 和 b 都转换为 double 类型，然后再进行运算，结果为 double 类型。  
     3. 取余运算再计算时,要求两个运算对象都必须时整型,其运算结果也是整型。 
2. 自增/自减运算符  
     |运算符|名称|
     |:---:|:---:|
     ++|自增运算符
     --|自减运算符
* 自加,自减运算符分为前缀方式和后缀方式。  
前缀方式：先自增/自减，后使用变量的值。  
后缀方式：先使用变量的值，后自增/自减。

## 算术表达式

由算术运算符、运算对象和括号连接起来的表达式称为算术表达式，运算对象可以是常量、变量和函数等。

### 优先级和结合性
运算优先级按由高到低依次执行。单目运算符优先级最高（++、--），其次是双目运算符（+、-、\*、/、%），双目运算符中 \*、/、% 的优先级高于 +、-。

## 赋值运算符

1. 基本赋值运算符  
“=”是基本赋值运算符，可以将数值、变量值或一个表达式的值赋值给一个变量。
2. 复合赋值运算符  
     |运算符|含义|举例|等价于|
     |:---:|:---:|:---:|:---:|
     +=|加赋值|a+=b|a=a+b
     -=|减赋值|a-=b|a=a-b
     \*=|乘赋值|a\*=b|a=a\*b
     /=|除赋值|a/=b|a=a/b
     %=|取余赋值|a%=b|a=a%b

## 赋值表达式

赋值表达式的一般形式为: 变量 = 表达式  
赋值表达式的作用是将一个表达式的值赋值给一个变量,因此其具有计算和赋值双重功能。

## 关系运算符
关系运算符|含义
:---:|:---:
\>|大于
\>=|大于等于
<|小于
<=|小于等于
==|等于
!=|不等于

## 关系表达式

格式:表达式1 关系运算符 表达式2  
关系表达式的运算结果是一个逻辑值 “真” 或者 “假”。用 “1” 表示 “真” ，“0” 表示 “假”。

### 优先级和结合性

1. 关系运算符的优先级
     符号|优先级
     :---:|:---:
     \>、<、>=、<=|1
     ==、!=|2

    关系运算符的优先级低于算术运算符,但是高于赋值运算符。
2. 关系运算符的结合性
    关系运算符都是双目运算符，其结合方向是左结合。因此使用多个运算符的表达式，在运算时，应注意关系运算符的左结合性特征，避免出错。

## 逻辑运算符

逻辑运算符|含义
:---:|:---:
&&|逻辑与
\|\| |逻辑或
!|逻辑非

## 逻辑表达式

格式：关系表达式1 逻辑运算符 关系表达式2

## 优先级

运算符|优先级
:---:|:---:
!|1
算术运算符|2
关系运算符|3
&&|4
\|\| |5
赋值运算符|6

## 逗号运算符与逗号表达式

格式：表达式1，表达式2，表达式3，...，表达式n  

从左到右依次执行，把最后一个表达式的值作为整个逗号表达式的值。  
逗号运算符优先级最低。

## 自动类型转换

占用内存空间少的数据类型向占用内存空间多的数据类型转换。

## 强制类型转换

格式：(类型说明符)(表达式)

## C语言的语句

1. 表达式语句  
表达式语句由表达式加上 “;” 组成
2. 函数调用语句
3. 控制语句
4. 复合语句  
把多条语句用一对花括号 “{ }” 括起来组成的一个语句块称为复合语句。
5. 空语句
   
## 赋值语句

格式：变量 = 表达式;  
1. 赋值符右边也可以是一个赋值表达式,可以连续给变量赋值。
2. 在定义变量中，不允许连续给多个变量赋初值。

## 数据的输入和输出函数

1. 格式输出函数 printf  
格式：printf("格式控制",输出列表);  
    格式字符|说明
    :---:|:---:
    d|以带字符的十进制形式输出整数，正数不输出符号
    o|以八进制无符号形式输出的整数，不输出前导符 0
    x,X|以十六进制无符号形式输出整数，不输出前导符 0x
    u|以无符号十进制形式输出整数
    c|以字符形式输出,只输出一个字符
    s|输出字符串
    f|以小数形式输出单、双精度数，隐含 6 位小数
    e,E|以指数形式输出实数
    g,G|选用 %f 或 %e 格式中输出宽度较短的一种格式，不输出无意义的 0。

    在 “%” 和上述格式字符之间还可以插入几种附加符号。
    字符|说明
    :---:|:---:
    l|用于长整形，可加在格式符 d、o、x、u 前面
    m(代表一个正整数)|数据最小宽度
    n(代表一个正整数)|对实数，表示输出 n 位小数；对字符串，表示截取的字符个数
    -|输出的数字或字符在域内向左靠  

2. 格式输入函数 scanf  
格式：scanf("格式控制字符串",输入项列表)  
格式控制字符串用双引号括起来，表示输入的格式，而输入项列表指出各变量的地址（变量名前加&）。  
    格式字符|说明
    :---:|:---:
    d|输入十进制整数
    o|输入八进制整数
    x|输入十六进制整数
    c|输入单个字符
    s|输入字符串
    f|输入浮点数(小数或指数形式)
    e|输入浮点数(指数形式)
    ld,lo,lx|输入长整型数据
    lf,le|输入长浮点型数据(双精度)

## 数学库函数  

常用数学库函数  
1. 指数函数 exp(x):计算 e 的 x 次方
2. 绝对值函数 fabs(x):计算 |x|
3. 以 e 为底的对数函数 log(x):计算 lnx
4. 幂函数 pow(x,y):计算 x 的根号 y 次方
5. 平方根函数 sqrt(x):计算根号下 x  

## 顺序结构

顺序结构的特点:
1. 从第一条语句开始顺序执行到最后一条
2. 每条语句都执行且只能执行一遍

## 选择结构

1. if...else 语句  
格式:  
```C
    if(表达式)
    {
     语句 1;
    }
    else
    {
     语句 2;
    }
```
2. if 语句  
格式：
```C
    if(表达式)
    {
     语句;
    }
```
3. 多分支 if 语句  
格式：
```C
    if(表达式 1)
    {
     语句 1;
    }
    else if(表达式 2)
    {
     语句 2;
    }
    ...
    else if(表达式 n)
    {
     语句 n;
    }
    else
    {
     语句 n+1;
    }
```
4. if 语句的嵌套  
格式：
```C
    if(表达式 1)
    {
     if(表达式 2)
     {
      语句 1;
     }
     else
     {
      语句 2;
     }
    }
    else
    {
     if(表达式 3)
     {
      语句 3;
     }
     else
     {
      语句 4;
     }
    }
```
5. 条件运算符  
格式：变量 =( 表达式 1)?( 表达式 2):( 表达式 3);  
6. switch 语句  
格式：
```C
    switch( 表达式 )
    {
     case 常量表达式 1: 语句 1; break;
     case 常量表达式 2: 语句 2; break;
     ...
     case 常量表达式 n: 语句 3; break;
     default: 语句 n+1; break;
    }
```  
 
多个 case 可以共用一组执行语句。

## 循环结构

1. while 语句  
格式：  
循环变量的初始值;
while( 循环条件表达式 )  
{  
 循环体语句;  
}  
2. do … while 语句  
格式:  
循环变量的初始值  
do  
{  
 循环体语句;  
}while( 循环条件表达式 );
3. for 语句  
格式：  
for( 表达式 1; 表达式 2; 表达式 3)  
{  
 循环体语句;  
}  
4. 循环的嵌套  
三种循环结构可以互相嵌套。

## break,continue 和 goto 语句

1. break 语句  

    格式：break;  

    当 break 语句用于循环语句时，可使程序终止循环而转去执行循环语句的后继语句。通常 break 语句总是与 if 语句一起配合使用，即满足条件时便跳出循环。
2. continue 语句 
 
    格式：continue;  

    continue 语句的作用是跳过循环体中 continue 后面的语句,继续执行下一次循环。 continue 语句只能用在循环语句中，常与 if 语句一起使用。
3. goto 语句  

    格式：goto< 语句标号 >;  

    goto 语句中的 < 语句标号 > 必须用标识符表示，不能用整数作为标号。

## 数组

数组的定义格式为：  
dataType arrayName[length];  
dataType 为数据类型， arrayName 为数组名称， length 为数组长度。  
数组中的每个元素都有一个序号，该序号从 0 开始并称这个序号为下标 (index) 。使用数组元素时需要指明下标，格式为：  

arrayName[index];  

arrayNname 为数组名， index 为下标。

## 数组元素在内存中是连续存放的  

数组是一个整体，其元素在内存中是连续存放的。也就是说，数组元素之间是互相挨着的，彼此之间没有一点点缝隙。连续的内存为指针操作（ 通过指针来访问数组元素 ）和内存处理（ 整块内存的复制，写入等 ）提供了便利，这使得数组可以作为缓存（ 临时存储数据的一块内存 ）使用。

## 一维数组的初始化  

可以在定义数组的同时就给数组赋值，数组元素的值由 { } 包围，各个值之间以 “,” 分隔。  
注意：  
1. 可以只给部分元素赋值。当 { } 中值的个数少于元素个数时，只给前面的元素按顺序赋值。剩余的元素会自动初始化为 0 值。
2. 只能给数组元素逐个赋值，不能给数组整体赋值。
3. 若给全部元素赋值，那么在定义数组时可以不给出数组长度。

## 二维数组

格式：dataType arrayName[length1][length2];  

length1 表示行数，length2 表示列数。

## 二维数组的初始化

二维数组的初始化可以按行分段赋值，也可以按行连续赋值。  
1. 可以只对部分元素赋值，未赋值的元素自动取 “ 零 ” 值。
2. 如果对二维数组的全部元素赋值，那么其第一维的长度可以不给出。
3. 二维数组可以看做是由一维数组嵌套而成的。因此一个二维数组可以按行分解为多个一维数组。

## 字符数组

字符数组是一系列字符的集合，也就是字符串 (string)。在 C 语言中，没有专门的字符串变量，没有 string 类型，因此通常用字符素组来存放一个字符串。  
C 语言规定，可以将字符串直接赋值给字符数组，例如：  
```C
char str[30]={"c.biancheng.net"};
char str[30]="c.biancheng.net";
```  
给字符数组赋值时，也可以将字符串一次性地赋值，不指明数组长度：
```C
char str[]={"c.biancheng.net"};
char str[]="c.biancheng.net";
```  
字符数组只有在定义时才能将整个字符串一次性地赋值给它，定义后只能一个字符一个字符地赋值。

## 字符串结束标志  

想要在内存中定义一个字符串，除了要知道它的开头，还要知道它的结尾。开头为字符数组名，而结尾需要在字符串末尾添加 '\0' 作为结尾。'\0' 在 C 语言中也被称为字符串结束标志，或者字符串结束符。由 "" 包围的字符串会自动再其末尾添加 '\0'。  
当逐个字符地给字符数组赋值并不会在字符串的末尾自动添加 '\0'，所以当用字符数组存储字符串时，要为 '\0'  留个位置。这意味着，字符数组的长度至少要比字符串的长度大一。  
为防止逐个字符地给字符数组赋值时会忘记添加结尾的 '\0'，可以现将字符数组全部初始化为零值。  

## 字符串长度

字符串长度是指，字符串中的字符个数，不包括结束标志 "\0"。  
求字符串长度需要用到 string.h 头文件中的 strlen 函数。  

格式：length=strlen(strname);  

length 为变量名，是整数。strname 是字符串的名字或字符数组的名字。

## 字符串的输入和输出

1. 字符串的输出  
C 语言中，有两个函数可以在控制台上输出字符串，分别是：  
puts 函数：输出字符串并自动换行，该函数只能输出字符串。  
printf 函数：通过格式控制符 %s 输出字符串，不能进行自动换行。除了字符串，printf 函数还能输出其他类型的数据。  
2. 字符串的输入  
C 语言中，有两个函数可以让用户从键盘上输入字符串，分别是：  
scanf 函数：通过格式控制符 %s 输入字符串。除了字符串，scanf 函数还能输入其他类型的数据。  
gets 函数：直接输入字符串，并且只能输入字符串。

    scanf 函数读取字符串时以空格为分隔符，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。  
gets 函数认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束了。

    在 scanf 函数中，字符数组名（字符串名字）作为输入项时不用再在字符数组名前添加 &，因为字符数组名会被自动转换为地址，无需再次指明地址。

## 字符串处理函数

使用字符串函数需要包含头文件 string.h string.h 是一个专门用来处理字符串的头文件，它包含了很多字符串处理函数。  

1. 字符串连接函数 strcat  
strcat 是 string catenate 的缩写，意思是把两个字符串拼接在一起。  

    格式：strcat(arrayName1,arrayName2);  

    strcat 函数将把 arrayName2 连接到 arrayName1 后面，并删除原来 arrayName1 最后的结束标志 '\0'。所以 arrayName1 必须足够长，要能够同时容纳 arrayName1 和arrayName2。  
stract 函数的返回值为 arrayName1 的地址。
2. 字符串复制函数 strcpy  
strcpy 是 string copy 的缩写，意思是字符串复制，即将字符串从一个地方复制到另外一个地方。  

    格式：strcpy(arrayName1,arrayName2);

    strcpy 函数会把 arrayName2 中的字符串拷贝到 arrayName1 中，并将其中的字符串结束标志 '\0' 也一同拷贝,同时字符串 arrayName1 中原来的内容就被覆盖掉了。
3. 字符串比较函数 strcmp  
ctrcmp 是 string compare 的缩写，意思是字符串比较。  

    格式：strcmp(arrayName1,arrayName2);  
    
    字符本身没有大小之分，strcmp 函数以各个字符对应的 ASCII 码值进行比较。strcmp 函数从两个字符串的第 0 个字符开始比较，如果它们相等，就继续比较下一个字符，直到遇见不同的字符，或者到字符串的末尾。  
返回值：若 arrayName1 和 arrayName2 相同，则返回 0；若 arrayName1 大于 arrayName2，则返大于 0 的值；若 arrayName1 小于 arrayName2，则返回小于 0 的值。  

## 数组中的排序  

### 冒泡排序法  

以从大到小为例，从数组头部开始，不断比较相邻的两个元素的大小，让较大的元素逐渐往后移动（交换两个元素的值），直到数组的末尾。经过一轮比较后，就可以找到最大的元素，并将它移到最后一个位置。  
第二轮比较仍然从数组头部开始，直到数组的倒数第二个元素为止。第二轮比较后可以找出第二大的元素，放在倒数第二位。
以此类推，进行 n-1(n 为数组长度) 轮排序后，就可以将所有的元素都排列好。

##  函数的分类

### 库函数和自定义函数

C语言自带的函数称为库函数（Library Function）。库（Library）是编程中的一个基本概念，可以简单地认为它是一系列函数的集合，在磁盘上往往是一个文件夹。  
除了库函数，我们还可以编写自己的函数，拓展程序的功能。自己编写的函数称为自定义函数，对于用户自定义函数，不但要在程序中定义函数本身，而且在主调函数模块中还必须对该被调函数进行类型说明，然后才能使用。

### 无参函数与有参函数  

所谓无参函数，是指在主调函数使用被调函数时，主调函数不向被调函数传递数据。无参函数一般用来执行特定的功能，可以有返回值，也可以没有返回值，但一般以没有返回值的情况居多。  
所谓有参函数，是指在主调函数调用被调函数时，主调函数通过参数向被调函数传递数据。在一般情况下，有参函数在执行被调函数是会得到一个值并返回给主调函数使用。

### 内部函数与外部函数  

1. 内部函数  
如果一个函数只能被本文件夹中的其他函数所调用，则称它为内部函数。在定义内部函数时，在函数名和函数类型的前面加上关键字 static。  

    格式：  
static 类型标识符 函数名 ( 形参表 );  
static int fun(int a,int b);  

    内部函数又称为静态 (static) 函数。使用内部函数，可以使函数只局限于所在文件。如果在不同的文件中有同名的内部函数，则它们之间互不干扰。通常把只能由同一文件使用的函数和外部变量放在一个文件中，在它们前面都添加关键字 static 使之局部化，其他文件不能引用。
2. 外部函数  
在定义函数时，如果在函数首部的最左端冠以关键字 extern，则表示此函数是外部函数，可供其他文件调用。  

    格式：extern int fun(int a,int b);

    这样函数 fun就可以被其他文件所调用。如果在自定义函数时省略关键字 extern，则也被默认为是外部函数。  
    在需要调用此函数的文件中，用关键字 extern 声明所用的函数是外部函数。

## 函数的定义  

C 语言的库函数是由编译系统事先定义好的，用户在使用时无需自己定义，只需要用 #include 命令将其有关的头文件包含到文件中即可。但所有的用户自定义函数均要 “先定义，后使用”。定义的目的是通知编译系统函数返回值的类型，函数的名字，函数的参数个数与类型，函数实现什么功能等。

### 无参函数的定义  

格式：  
类型名 函数名()  
{  
函数体  
}  
或  
类型名 函数名(void)  
{  
 函数体  
}  
说明：类型名指定函数返回值的类型，省略时，默认函数返回值的类型为 int，void 表示函数没有参数。函数体包含声明部分和语句部分，声明部分主要是变量的声明或所调用函数的声明，执行部分由执行语句组成，函数的功能正是由这些语句实现的。函数体可以既有声明部分又有语句部分，也可以只有语句部分，还可以两者皆无（空函数）。调用空函数不产生任何有效操作。  
一般情况下无参函数没有返回值，此时函数类型名为 void。  

### 有参函数的定义  

格式：  
类型名 函数名（形式参数列表）  
{  
 函数体  
}

说明：有参函数比无参函数多了一项内容，即形式参数列表。形式参数（简称形参）可以是各种类型的变量，各形式参数之间用逗号分隔。在进行函数调用时，调用函数将赋予这些形参实际的值。

### 空函数的定义  

格式：  
类型名 函数名（）  
{ }  

函数体是空的，调用此函数时，什么工作也不做。

## 函数参数和函数的值  

### 参数  
函数的一个明显特征是使用时加括号 ()，有必要的话,括号中还要包含数据或变量，称其为参数(Parameter)。参数是函数需要处理的数据。  
例：strlen(str1) 用来计算字符串长度，str1 就是参数。  
puts("C 语言") 用来输出字符串，"C 语言" 就是参数。  
C 语言函数的参数会出现在两个地方，分别是函数定义处和函数调用处，这两个地方的参数是有区别的。  
1. 形参（形式参数）  
在函数定义中出现的参数可以看作是一个占位符，它没有数据，只能等待函数被调用时接受传递进来的数据，所以称其为形式参数，简称形参。  
2. 实参（实际参数）  
函数被调用时给出的参数包含了实际的数据，会被函数内部的代码使用，所以称其为实际参数，简称实参。  
3. 形参和实参的区别与联系  
    1. 形参变量只有在函数被调用时才会分配内存，调用结束后，立刻释放内存，所以形参变量只有在函数内部有效，不能在函数外部使用。  
    2. 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的数据，在进行函数调用时，它们都必须有确定的值，以便把这些值传递给形参，所以应该提前用赋值、输入等办法使实参获得确定值。  
    3. 实参和形参在数量上、类型上和顺序上必须严格保持一致，否则会发生 “类型不匹配的错误” 。当然，如果能够进行自动类型转换，或者进行了强制类型转换，那么实参类型也可以不同于形参类型。  
    4. 函数调用中发生的数据传递是单向的，即只能把实参的值传递给形参，而不能把形参的值反向地传给实参。换句话说，一旦完成数据的传递，实参和形参就再也没有联系了。所以，在函数调用过程中，形参的值发生改变并不会影响实参。  
    5. 形参和实参虽然可以同名，但它们之间是互相独立和互不影响的，因为实参在函数外部有效，而形参只在函数内部有效。  
    6. 实参与形参结合的原则。当实参为常量、变量、表达式或数组元素时，对应的形参只能是变量名；当实参为数组名时，对应的形参必须是同类型的数组名或指针变量。

### 返回值  

当被调用函数完成一定的功能后，可将处理的结果返回到调用函数，这种数据传递称为函数的返回值。如果函数有返回值，则在函数体内应包含 return 语句。  
格式：return ( 表达式 );  
或者 return 表达式;  
作用是将表达式的值返回给调用函数，结束被调用函数的执行，并将程序的控制权返回到调用它的函数。  

注意：
1. 函数返回值的类型应与函数的类型一致。如不一致，以函数类型为准，对返回值进行类型转换，然后传递给调用函数。  
2. 一个函数可以有多个 return 语句，但只可能执行其中一个。

## 函数的调用  

函数的使用是通过函数的调用实现的。所谓函数调用，就是调用函数向被调函数传递数据并将控制权交给被调用函数，当被调用函数执行完成后，将执行结果回传给调用函数并交回控制权。  

### 函数调用的方式  

1. 在表达式中调用函数  
当函数出现在一个表达式中，这是要求函数必须返回一个确定值，而这个值作为参考加表达式运算的一部分。
2. 函数语句调用  
把函数的调用通过一条语句来实现，这就称为函数语句调用。函数语句调用是最常使用的调用函数的方式。
3. 把函数作为参数使用  
函数调用作为一个函数的实际参数，即将函数返回值作为实际参数传递到函数中使用。

### 函数的嵌套调用  

函数的嵌套调用是指在调用一个函数的过程中，该函数又调用另一个函数。在 C 语言中，各函数均处于平等关系，任何一个函数都可以调用和被调用，但 main 函数例外。C 语言不允许嵌套定义函数。

### 函数的递归调用

在 C 语言中，一个函数除了可以调用其他函数以外，还可以直接或间接调用自己，这种函数自己调用自己的形式称为函数的递归调用，带有递归调用的函数也称为递归函数。  

### 数组作为函数参数  

数组可以作为函数的参数使用，完成函数间的数据传递。数组作为函数参数有两种形式，一种是把数组元素作为实参使用，另一种是把数组名作为函数的形参和实参使用。  
1. 数组元素作为函数实参  
数组元素就是下标变量，它与普通变量并无区别。因此，将数组元素作为函数实参使用与将普通变量作为函数实参使用是完全相同的。在发生函数调用时，把作为实参的数组元素的值传递给形参，实现单向值的传递。  
2. 数组名作为函数参数  
在 C 语言中，数组名代表数组的首地址，数组名作为函数的参数，此时形参和实参所指向的是同一块存储单元，即形参数组可以访问实参数组所在的存储单元，并且还能改变这些单元内容，从而使实参数组元素的值被改变。  
格式：函数名（ 数组名 ）  
由于数组名实际上是数组第一个元素的地址，调用函数时，当用数组名作为实参时，实际上传递给形参一个地址值，即实参数组的首地址，对应的形参应该是数组名或一个指针变量。  
数组名作为实参时，函数中对应的形参可用 3 种形式进行说明：  
   1. x(int b[10])
   2. x(int b[])
   3. x(int *b)  

    注意：形参数组的长度可以省略。为了在被调用函数中满足处理数组元素的需要，可另设一个参数，用来传递数组元素的个数。  
    当函数参数是一维数组时，形参数组无需指定大小，但数组名后面的方括号是不能省略的。也可用多维数组名作为实参和形参，在被调用函数中对形参数组进行自定义时，可以指定每一维的长度，也可省略第一维的长度。  

    函数参数传递的规则  
    实参|形参|传递数据
    :---:|:---:|:---:
    基本变量<br>常数<br>表达式<br>数组元素|基本变量|传值
    数组名|数组名<br>指针变量|传址

## 全局变量和局部变量  

变量的作用域，也就是说在不同的地方定义变量，其作用域是不一样的。变量的作用域就是变量的有效范围。C 语言只允许在 3 个地方定义变量：  
1. 函数内部的声明部分
2. 所有函数的外部
3. 复合语句中的声明部分  

变量定义的位置不同，其作用域也不同。从变量的作用域来分，可以将其分为局部变量和全局变量。

### 局部变量  

在一个函数内部定义的变量称为局部变量。其作用范围仅限于本函数，即只在本函数范围内有效，在其他函数内不能使用。  
在 main 函数中定义的变量也只在主函数中有效，而不是在整个文件中都有效，主函数不能使用其他函数中定义的变量。不同函数中可使用相同名字的变量，它们代表不同的对象，互不干扰。形参是属于被调函数的局部变量，实参是属于调用函数的局部变量。  
在函数内部，可在复合语句中定义变量，这个变量只在本复合语句中有效。

### 全局变量  

全局变量是在函数外部定义的变量，也称为外部变量。其作用范围是从被定义的地方开始直至本源程序文件的结束。全局变量只能被定义在程序的最前面，即第一个函数的前面，其作用范围将覆盖源程序文件中的各函数。  

使用全局变量的优点：  
1. 增加了各函数间数据传递的渠道。函数调用只能返回一个函数值，而利用全局变量则可以从函数中得到一个以上的返回值。  
2. 利用全局变量可以减少函数中实参和形参的个数。  

使用全局变量的缺点：  
1. 全局变量在程序运行过程中始终占用存储单元，而不是在函数被调用时才临时分配存储单元。
2. 使函数的通用性降低。因为函数的运行要依赖于全局变量，所以函数很难进行移植。
3. 由于每个函数执行时都有可能改变全局变量的值，这就使得程序容易出错，因此非必要情况下不建议使用全局变量。  

在同一个源程序中，若全局变量与局部变量同名，则在局部变量的作用范围内，全局变量不起作用，即此时全局变量被局部变量所 “ 屏蔽 ” 。在同一源文件内，对于使用在前，定义在后的全局变量，应在使用前用关键字 extern 加以声明，声明后的全局变量即可以使用。

## 变量的存储类别  

变量从定义开始分配存储单元，到运行结束存储单元被回收，整个过程称为变量生命期。影响变量生命期的是变量的存储类型，也就是说变量的存储类型不同，其生命期也是不同的。  

### 静态存储与动态存储  

C 语言的数据存储区分为动态存储区和静态存储区，全局变量和静态局部变量属于静态存储区，自动变量属于动态存储区。变量的存放位置决定了变量的生命期。  
从变量的生命期来分，可以将变量的存储类型分为静态存储方式和动态存储方式。静态存储方式是指在程序运行期间需要给变量分配固定的存储空间方式；动态存储方式是指在程序运行期间根据需要给变量动态分配存储空间的方式。

### 变量的存储类型

在 C 语言中变量有两个属性，即前面已经介绍过的变量的数据类型以及变量的存储类型。用变量的存储类型说明来确定变量的存放位置。  
带有存储类型的变量，其定义一般形式为：  
存储类型 数据类型 变量名;  
在 C 语言中，变量的存储类型有四种：auto( 自动类型 )、static( 静态类型 )、register( 寄存器类型 ) 和 extern( 外部类型 )。  
1. 自动变量 (auto)  
自动变量用关键字 auto 表示。函数体中说明的变量、函数的参数、程序块中定义的变量称为自动变量。  
格式：auto 类型名 变量名;  
自动变量存放在动态存储区，是动态分配存储空间的。C 语言规定：在局部变量的定义中，可省略关键字 “auto” ，即没有指明存储类型的变量，一律隐含为自动变量。  
2. 静态变量 (static)  
格式:static 类型名 变量名；  
static 变量的存储单元被分配在数据存储区的静态存储区中。如果函数中的局部变量的值在函数调用结束后任然能保留，便于下一次调用该函数时使用，可以将局部变量定义为 static 类型。局部变量和全局变量都可以说明为 static 类型。 
静态局部变量的生命期与全局变量的生命期相同，作用域与局部变量的作用域相同。  
全局变量无论是否被说明为 static 类型，都将占用静态存储区。静态局部变量可以改变其生命期，但不能改变它的作用域，即静态局部变量不能被其他函数所引用，只是扩大了局部变量的生命期。  
3. 寄存器变量 (register)  
register 变量也是自动变量，它与 auto 型变量的区别在于：register 变量的值存放在寄存器中而不是内存中。寄存器是 CPU 芯片内部的存储器，访问速度极快。常把一些对运行速度有较高要求、需要频繁引用的变量定义为 register 型。register 说明符是过时的说明符，因为目前大多数编译器都可以做到程序优化，程序根据优化的结果决定哪些变量是 register 型变量，因此由程序员指定的 register 型变量可能无效。  
说明：  
    1. 寄存器变量只能用于基本整型、短整型和字符型变量。
    2. 寄存器变量分配方式是动态分配的。
    3. 由于 CPU 中寄存器数目有限，通常只把少数使用频繁的变量定义为寄存器变量，而对超出寄存器的数目的寄存器变量按自动变量处理。
    4. 只有自动变量和形参可以作为寄存器变量。
4. 外部变量 (extern)  
extern 变量即外部变量，是在程序中声明已在函数的外部定义过的变量全局变量。  
格式：extern 类型名 变量名;  
extern 只能声明已经存在的变量，而不能定义变量。外部变量的作用域为从变量的定义处开始到本程序的结束，在此作用域内，外部变量可以为程序中各个函数所使用。  
如果在定义点之前的函数想引用全局变量，则应该在引用之前用关键字 entern 对该变量声明，表示该变量是一个已经定义的外部变量。有了此声明，即可合法的使用该变量。  
对于由多个源文件组成的 C 程序，C 语言规定：  
    1. 对共用的外部变量只需在任一源文件中定义一次，则在其他源文件中用 extern 对其声明后即可使用。
    2. 如果希望外部变量仅限于本文件使用，则在定义外部变量时前面加一个 static 说明。 

## 指针的相关概念  

### 地址和指针  

系统的内存就好比是带有编号的房间，如果想使用内存就需要得到房间编号。定义一个整型变量 i ，一个整型变量需要 4 个字节，如果该变量的起始编号为 1000 ，那么编译器为该变量分配的编号为 1000 ~ 1003。  
地址就是内存区中对每个字节的编号，如 1000、1001、1002和1003 就是地址。  
C 程序中所定义的每一个变量都会被分配若干个连续的内存单元，变量的值就存放在这些内存单元中；变量被分配的内存单元数量由变量的类型决定，除了共用体外，不同变量使用不同的内存单元。

### 指针与指针变量  

指针就是某个对象所占用的内存单元的首地址。例如，变量 i 的首地址 1000 就是变量 i 的指针。变量的地址就是变量和指针二者之间连接的纽带，如果一个变量包含了另一个变量的地址，则可以理解成第一个变量指向第二个变量。存放变量地址的变量称为指针变量，指针变量是指向一个变量的地址。  
1. 指针变量的一般形式  
类型说明 * 指针变量名  
其中 “*” 表示该变量是一个指针变量，类型说明表示该指针变量所指向的变量的数据类型，例如 int *q。  
2. 指针变量的赋值  
指针变量同普通变量一样，使用之前不仅需要定义，而且必须赋予具体的值，未经赋值的指针变量不能使用，同时，指针变量赋值只能赋予地址，而不能赋予任何其他数据。  
格式：指针变量名 = & 变量名；  
给一个指针变量赋值有两种方法：  
    1. 在定义指针变量的同时进行赋值，例如：  
        ~~~ C
        int a;
        int *p=&a;
        ~~~
    2. 先定义指针变量，然后再赋值，例如：
        ~~~ C
        int a;
        int *p;
        p=&a;
        ~~~
    注意：这两种赋值语句的区别在于如果在定义完指针变量之后再赋值不能加 “*”。  
3. 指针变量的引用  
引用指针变量是对变量进行间接访问的一种形式。  
指针变量的应用形式为：* 指针变量  
4. 运算符 “&” 和 “*”
运算符 & 是一个返回操作数地址的单目运算符，也叫取地址运算符，例如：  
    ~~~ C
    p=&i;
    ~~~  
    就是将 i 的内存地址赋值给 p，这个地址是该变量在计算机内部的存储位置。  
    运算符 * 是单目运算符，也叫指针运算符，作用是返回指定的地址内的变量的值。例如：  
    ~~~ C
    q=*p;  
    ~~~  
    如果 p 中装有变量 i 的内存地址，则变量 i 的值赋给 q，假设变量 i 的值是 5，则 q 的值也是 5。  
5. “&\*” 和 “*&” 区别  
例如：  
    ~~~ C
    int a;
    p=&a;
    ~~~
    “&” 和 “\*” 运算符优先级别相同，按自右而左的方向结合。  
    “&\*” 先进行 “\*” 运算，“\*p” 相当于变量 a，再进行 “&” 运算，“&\*p” 相当于取变量 a 的地址。  
    “\*&a” 先进行 “&” 运算，“&a” 就是取变量 a 的地址，然后执行 “\*” 运算，“\*&a” 相当于取变量 a 所在地址的值，实际就是变量 a。  

### 指针的自增自减运算  

指针的自增自减运算不同于普通变量的自增自减运算，例如：基本整型变量 i 在内存中占 4 个字符，假设指针 p 是指向变量 i 的地址，那么 p++ 不是在地址上加 1，而是指向下一个存放基本整型变量的地址。  

## 指针与一维数组  

### 指针与一维数组的关系

数组是最基本的构造类型，是相同类型数据的有序集合。数组中的元素按顺序存放在地址连续的内存单元中，每一个数组元素都有各自的地址，数组名是数组首元素的地址。对数组元素的访问，可以使用下标，也可以使用指针变量，移动指针可以指向数组中的任意一个元素。  

### 一维数组与指针的定义  

当定义一个一维数组时，系统会在内存中为该数组分配一个存储空间，其数组的名称就是数组在内存中的首地址，若再定义一个指针变量，并将数组的首地址传递给指针变量，则该指针就指向了这个一维数组。  
在 C 语言中，可以用 a+n 表示数组元素的地址。*(a+n) 表示数组元素。  
表示指针的移动可以使用 “++” 和 “--” 两个运算符。  

## 指针与二维数组  

二维数组的各个元素在内存中是连续存放的，存放方式与一维数组并无区别，可以将二维数组当做一维数组进行处理，指针变量指向二维数组某元素的格式为： 

     指针变量名 =& 二维数组 [ 行下标 ][ 列下标 ]  
     指针变量名 =* 二维数组名  
     指针变量名 = 二维数组 [ 行下标 ]  
当行下标和列下标均为 0 是时，指针变量指向二维数组首元素的地址，引用该数组元素的方法是：  

    * 指针变量  

### 指向二维数组的行指针变量  

由于二维数组的每一行都被视为一个一维数组，所以可以定义一个指针来指向每一行的一维数组，则行指针变量是指向一行数组元素的起始地址。格式为：  

    类型名 (* 指针变量名)[n]  
其中，类型名为指针变量名所指向数组的数据类型。n 表示由一个二维数组分解为多个一维数组的长度，也就是所指向的二维数组的列数。格式中，()、* 和 [n] 都不可省略。  
注意：行指针变量用于指向一行数组元素的起始地址，而非数组中的元素。定义行指针变量以后，只要将二维数组的首地址赋给行指针变量，则行指针变量就与二维数组建立了联系，二维数组也就成为行指针变量指向的对象。此时，就可以用指针法访问该二维数组的元素了。  

## 指针与字符串  

### 字符串与字符指针  

C 语言中可以使用字符指针来操作字符串。  
例如：  
~~~C  
char *str[]="hello";
puts(str);  
~~~  
字符串 “hello” 在内存中以字符数组的形式存储，语句 “char *str="hello";” 的含义是指针 str 指向字符串 “hello” 的首字符，这里的 “=” 号表示将字符串 “hello” 的第一个字符的地址赋给 str。

### 使用字符数组与字符指针处理字符串的区别  

虽然字符数组和字符指针都可以用于处理字符串，但二者之间还是有区别的。  
1. 赋值方法不同。字符指针可以在定义后赋值，字符数组不行。  
2. 系统为其分配内存单元的方法不同。字符数组被定义以后，系统为其分配一段连续的内存单元，字符数组名为这段连续内存单元的首地址；而字符指针变量被定义以后，系统为其分配一个存放指针值（ 地址 ）的内存单元，其指向的对象并不明确。但字符指针一旦指向某个具体对象，就可以用于输入了。  
3. 修改（地址）的方法不同。字符指针的值（地址）可以被反复修改，也就是可以通过修改其值使其可以指向字符串中的任意位置；但字符数组名只能被引用，而不能被修改。  

### 字符串数组  

字符数组是一个一维数组，而字符串数组是一个将字符串作为数组元素的数组，可视其为一个二维字符数组。  
定义一个简单的字符串数组，例如：  
~~~C  
char country[5][20]={"China","Japan","Ruassia","Germany","Switzerland"};  
~~~  
字符串数组变量 country 被定义为含有 5 个字符串的数组，每个字符串的长度为20。  
上面的字符串数组中，像 “China” 和 “Japan” 这样的字符串的长度仅为 5，加上字符串结束符其长度也仅为 6，而内存中却要给它们分别分配一个 20 字节的空间，这样就会造成资源浪费。为了解决这个问题，可以使用指针数组，使每个指针指向所需的字符常量。  
一维指针数组的定义格式为：  

    类型名 *数组名 [数组长度]  

## 指针与函数  

### 指针作函数的参数  

指针作为函数的形参时，在形参说明时需要使用格式 “类型名 * 指针名”。* 号不能省略，而在函数定义的说明部分，* 号的作用是类型说明符。  
指针作为函数参数，在被定义、声明会调用时，数据类型都必须一致，如果不一致，编译就会报错。  
指针作为函数的形参时，函数中可以修改指针所指向的对象，利用这个特性，一个函数可以获得多个返回值，只要在定义这个函数时使用多个指针变量作为形参即可。  

### 返回指针值的函数  

一个函数可以返回一个整型值、字符值、实型值等，也可以返回指针型的数据（指针值），即地址，返回指针值的函数简称为指针函数。  
定义指针函数的一般形式为：  

    类型名 * 函数名（参数列表）  

如：  

    int *max(int n)  

其中 max 是函数名，n 是函数 max 的形参，函数名前面的 * 表示调用该函数后返回一个指向整型数据的指针（地址）。